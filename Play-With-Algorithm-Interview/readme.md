## 玩儿转算法面试 - 课程官方代码仓

大家好， 欢迎大家来到我在[慕课网](http://www.imooc.com/)上的实战课程[《玩儿转算法面试》](http://coding.imooc.com/class/82.html)的官方代码仓。这个代码仓将不仅仅包含课程的所有源代码，还将发布课程的更新相关内容，勘误信息以及计划的更多可以丰富课程的内容，如更多分享，多多练习，等等等等。课程源码暂时只提供C++语言的源代码。关于更多语言的支持，今后有时间，我会慢慢更新这个代码仓（不过预计会是蜗牛速了>_<）。大家可以下载、运行、测试、修改。如果你发现了任何bug，或者对课程中的任何内容有意见或建议，欢迎和我联系：）

**个人网站**：[liuyubobobo.com](http://liuyubobobo.com)

**电子邮件**：[liuyubobobo@gmail.com](mailto:liuyubobobo@gmail.com)

**微博**: [刘宇波bobo http://weibo.com/liuyubobobo](http://weibo.com/liuyubobobo)

**知乎**: [刘宇波 http://www.zhihu.com/people/liuyubobobo](http://www.zhihu.com/people/liuyubobobo)

**知乎专栏：**[是不是很酷 https://zhuanlan.zhihu.com/liuyubobobo](https://zhuanlan.zhihu.com/liuyubobobo)

**个人公众号：是不是很酷**：）

![qrcode](qrcode.jpg)


## 课程相关其他代码仓

* [**《算法与数据结构》课程**](https://coding.imooc.com/class/71.html), 代码仓: [Play-with-Algorithms](https://github.com/liuyubobobo/Play-with-Algorithms)

* [**《看得见的算法》课程**](https://coding.imooc.com/class/138.html), 代码仓: [Play-with-Algorithm-Visualization](https://github.com/liuyubobobo/Play-with-Algorithm-Visualization)

* [**《玩转数据结构》课程**](https://coding.imooc.com/class/207.html), 代码仓: [Play-with-Data-Structures](https://github.com/liuyubobobo/Play-with-Data-Structures)

* 我的**LeetCode题解代码仓**：[Play Leetcode](https://github.com/liuyubobobo/Play-Leetcode) （注：以C++实现为主）

* **LeetCode Explore题解代码仓**：[Play Leetcode Explore](https://github.com/liuyubobobo/Play-Leetcode-Explore) （注：以C++实现为主）
    * [Leetcode Explore](https://leetcode.com/explore/) 是 Leetcode 在2017年底上线的新模块，分门别类地整理了Leetcode上的问题。如果刷Leetcode一时不知从哪里下手，可以从Leetcode Explore为指引开始：）
    

## 本代码仓包括

* [课程更新信息](https://github.com/liuyubobobo/Play-with-Algorithm-Interview#课程更新信息)
* [课程及补充内容源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview#课程源码目录)
* [课程练习题及扩展练习题源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview#课程练习题及扩展练习题源码)
* 课程补充内容 [整理中][不断更新]
* 课程勘误信息 [整理中][不断更新]


## 课程更新信息

* **v 2.0** 添加课程Java源码

* **v 1.0** 全套课程上线


## 课程源码目录 

| **第一章：算法面试到底是什么鬼** | [无代码] | [无代码] |
| :--- | :---: | :---: |
| 1-1 算法面试不仅仅是正确的回答问题 | [无代码] | [无代码] |
| 1-2 算法面试只是面试的一部分 | [无代码] | [无代码] |
| 1-3 如何准备算法面试 | [无代码] | [无代码] |
| 1-4 如何会打算发面试问题 | [无代码] | [无代码] |
| **第二章：面试中的复杂度分析** | [章节C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/02-Time-Complexity/Course%20Code%20(C%2B%2B)/) | [章节Java源码](02-Time-Complexity/Course%20Code%20(Java)/) |
| 2-1 究竟什么是大O (Big O) | [无代码] | [无代码] |
| 2-2 对数据规模有一个概念 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/02-Time-Complexity/Course%20Code%20(C%2B%2B)/02-Time-Complexity-Basic/) | [Java源码](02-Time-Complexity/Course%20Code%20(Java)/02-Time-Complexity-Basic/src/) |
| 2-3 简单的复杂度分析 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/02-Time-Complexity/Course%20Code%20(C%2B%2B)/03-Common-Code-for-Time-Complexity/) | [Java源码](02-Time-Complexity/Course%20Code%20(Java)/03-Common-Code-for-Time-Complexity/src/) |
| 2-4 亲自试验自己算法的复杂度 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/02-Time-Complexity/Course%20Code%20(C%2B%2B)/04-Time-Complexity-Experiments/) | [Java源码](02-Time-Complexity/Course%20Code%20(Java)/04-Time-Complexity-Experiments/src/) |
| 2-5 递归算法的时间复杂度 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/02-Time-Complexity/Course%20Code%20(C%2B%2B)/05-Recursion-Time-Complexity/) | [Java源码](02-Time-Complexity/Course%20Code%20(Java)/05-Recursion-Time-Complexity/src/) |
| 2-6 均摊时间复杂度分析（Amortized Time Analysis） | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/02-Time-Complexity/Course%20Code%20(C%2B%2B)/06-Amortized-Time/) | [Java源码](02-Time-Complexity/Course%20Code%20(Java)/06-Amortized-Time/src/) |
| 2-7 避免复杂度的震荡 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/02-Time-Complexity/Course%20Code%20(C%2B%2B)/07-Amortized-Time-2/) | [Java源码](02-Time-Complexity/Course%20Code%20(C%2B%2B)/07-Amortized-Time-2/src/) |
| 补充代码1: 动态空间的数组结构 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第二章 第2-9小节](https://coding.imooc.com/lesson/207.html#mid=13407) |
| 补充代码2: 动态空间的栈结构 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第三章 第2小节](https://coding.imooc.com/lesson/207.html#mid=13418) |
| 补充代码3: 动态空间的队列结构 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第三章 第5-8小节](https://coding.imooc.com/lesson/207.html#mid=13422) |
| 补充代码4: 动态空间的堆结构 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第八章](https://coding.imooc.com/lesson/207.html#mid=13738) |
| **第三章：数组中的问题其实最常见** | [章节C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/03-Using-Array/Course%20Code%20(C%2B%2B)/) | [章节Java源码](/03-Using-Array/Course%20Code%20(Java)/) |
| 3-1 从二分查找法看如何写出正确的程序 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/03-Using-Array/Course%20Code%20(C%2B%2B)/01-Binary-Search/) | [Java源码](03-Using-Array/Course%20Code%20(Java)/01-Binary-Search/src) |
| 3-2 改变变量定义，依然可以写出正确的算法 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/03-Using-Array/Course%20Code%20(C%2B%2B)/02-Binary-Search-II/) | [Java源码](03-Using-Array/Course%20Code%20(Java)/02-Binary-Search-II/src/) |
| 3-3 在LeetCode上解决第一个问题 Move Zeros | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/03-Using-Array/Course%20Code%20(C%2B%2B)/03-Move-Zeroes/) | [Java源码](03-Using-Array/Course%20Code%20(Java)/03-Move-Zeroes/src) |
| 3-4 即使简单的问题，也有很多优化的思路 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/03-Using-Array/Course%20Code%20(C%2B%2B)/04-Move-Zeroes-II/) | [Java源码](03-Using-Array/Course%20Code%20(Java)/04-Move-Zeroes-II/src/) |
| 3-5 三路快排partition思路的应用 Sort Color | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/03-Using-Array/Course%20Code%20(C%2B%2B)/05-Sort-Colors/) | [Java源码](03-Using-Array/Course%20Code%20(Java)/05-Sort-Colors/src/) |
| 3-6 对撞指针 Two Sum II - Input Array is Sorted | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/03-Using-Array/Course%20Code%20(C%2B%2B)/06-Two-Sum-II/) | [Java源码](03-Using-Array/Course%20Code%20(Java)/06-Two-Sum-II/src/) |
| 3-7 滑动窗口 Minimum Size Subarray Sum | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/03-Using-Array/Course%20Code%20(C%2B%2B)/07-Minimum-Size-Subarray-Sum/) | [Java源码](03-Using-Array/Course%20Code%20(Java)/07-Minimum-Size-Subarray-Sum/src/) |
| 3-8 在滑动窗口中做记录 Longest Substring Without Repeating Characters | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/03-Using-Array/Course%20Code%20(C%2B%2B)/08-Longest-Substring-Without-Repeating-Characters/) | [Java源码](03-Using-Array/Course%20Code%20(Java)/08-Longest-Substring-Without-Repeating-Characters/src/) |
| 补充代码1: 各种排序算法的系统剖析 | [算法与数据结构](https://coding.imooc.com/class/71.html) | [第二，三，四章](https://coding.imooc.com/lesson/71.html#mid=1446) |
| **第四章：查找表相关问题** | [章节C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/04-Using-Hash-Table/Course%20Code%20(C%2B%2B)/) | [章节Java源码](04-Using-Hash-Table/Course%20Code%20(Java)/) |
| 4-1 set的使用 Intersection of Two Arrays | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/04-Using-Hash-Table/Course%20Code%20(C%2B%2B)/01-Intersection-of-Two-Arrays/) | [Java源码](04-Using-Hash-Table/Course%20Code%20(Java)/01-Intersection-of-Two-Arrays/src/) |
| 4-2 map的使用 Intersection of Two Arrays II | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/04-Using-Hash-Table/Course%20Code%20(C%2B%2B)/02-Intersection-of-Two-Arrays-II/) | [Java源码](04-Using-Hash-Table/Course%20Code%20(Java)/02-Intersection-of-Two-Arrays-II/src/) |
| 4-3 set和map不同底层实现的区别 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/04-Using-Hash-Table/Course%20Code%20(C%2B%2B)/03-More-About-Set-And-Map/) | [Java源码](04-Using-Hash-Table/Course%20Code%20(Java)/03-More-About-Set-And-Map/) |
| 4-4 使用查找表的经典问题 Two Sum | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/04-Using-Hash-Table/Course%20Code%20(C%2B%2B)/04-Two-Sum/) | [Java源码](04-Using-Hash-Table/Course%20Code%20(Java)/04-Two-Sum/src/) |
| 4-5 灵活选择键值 4Sum II | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/04-Using-Hash-Table/Course%20Code%20(C%2B%2B)/05-4Sum-II/) | [Java源码](04-Using-Hash-Table/Course%20Code%20(Java)/05-4Sum-II/src/) |
| 4-6 灵活选择键值 Number of Boomerangs | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/04-Using-Hash-Table/Course%20Code%20(C%2B%2B)/06-Number-of-Boomerangs/) | [Java源码](04-Using-Hash-Table/Course%20Code%20(Java)/06-Number-of-Boomerangs/src/) |
| 4-7 查找表和滑动窗口 Contain Duplicate II | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/04-Using-Hash-Table/Course%20Code%20(C%2B%2B)/07-Contains-Duplicate-II/) | [Java源码](04-Using-Hash-Table/Course%20Code%20(Java)/07-Contains-Duplicate-II/src/) |
| 4-8 二分搜索树底层实现的顺序性 Contain Duplicate III | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/04-Using-Hash-Table/Course%20Code%20(C%2B%2B)/08-Contains-Duplicate-III/) | [Java源码](04-Using-Hash-Table/Course%20Code%20(Java)/08-Contains-Duplicate-III/src/) |
| 补充代码1：基于链表和二分搜索树实现的set和map | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第七章](https://coding.imooc.com/lesson/207.html#mid=13703) |
| 补充代码2: 基于AVL树实现的set和map | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第十二章](https://coding.imooc.com/lesson/207.html#mid=14346) |
| 补充代码3: 基于红黑树实现的set和map | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第十三章](https://coding.imooc.com/lesson/207.html#mid=15086) |
| 补充代码2: 基于哈希表实现的set和map | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第十四章] |
| **第五章：在链表中穿针引线** | [章节C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/05-About-Linked-List/Course%20Code%20(C%2B%2B)/) | [章节Java源码](05-About-Linked-List/Course%20Code%20(Java)/) |
| 5-1 链表，在节点间穿针引线 Reverse Linked List | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/05-About-Linked-List/Course%20Code%20(C%2B%2B)/01-Reverse-Linked-List/) | [Java源码](05-About-Linked-List/Course%20Code%20(Java)/01-Reverse-Linked-List/src/) |
| 5-2 测试你的链表程序 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/05-About-Linked-List/Course%20Code%20(C%2B%2B)/02-Test-Your-Linked-List/) | [Java源码](05-About-Linked-List/Course%20Code%20(Java)/02-Test-Your-Linked-List/src/) |
| 5-3 设立链表的虚拟头结点 Remove Linked List Elements | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/05-About-Linked-List/Course%20Code%20(C%2B%2B)/03-Remove-Linked-List-Elements/) | [Java源码](05-About-Linked-List/Course%20Code%20(Java)/03-Remove-Linked-List-Elements/src/) |
| 5-4 复杂的穿针引线 Swap Nodes in Pairs | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/05-About-Linked-List/Course%20Code%20(C%2B%2B)/04-Swap-Nodes-in-Pairs/) | [Java源码](05-About-Linked-List/Course%20Code%20(Java)/04-Swap-Nodes-in-Pairs/src/) |
| 5-5 不仅仅是穿针引线 Delete Node in a Linked List | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/05-About-Linked-List/Course%20Code%20(C%2B%2B)/05-Delete-Node-in-a-Linked-List/) | [Java源码](05-About-Linked-List/Course%20Code%20(Java)/05-Delete-Node-in-a-Linked-List/src/) |
| 5-6 链表与双指针 Remove Nth Node From End of List | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/05-About-Linked-List/Course%20Code%20(C%2B%2B)/06-Remove-Nth-Node-From-End-of-List/) | [Java源码](05-About-Linked-List/Course%20Code%20(Java)/06-Remove-Nth-Node-From-End-of-List/src/) |
| 补充代码1：链表的完整底层实现 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第四章](https://coding.imooc.com/lesson/207.html#mid=13429) |
| 补充代码2：通过链表深刻理解递归 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第五章](https://coding.imooc.com/lesson/207.html#mid=13463) |
| 补充代码3：Floyd's 环检测算法 | [C++源码] | [Java源码] |
| **第六章：栈，队列，优先队列** | [章节C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/) | [章节Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/) |
| 6-1 栈的基础应用 Valid Parentheses | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/01-Valid-Parentheses/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/01-Valid-Parentheses/src/) |
| 6-2 栈和递归的紧密联系 Binary Tree Preoder, Inorder and Posorder Traversal | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/02-Recursion-and-Stack/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/02-Recursion-and-Stack/src/) |
| 6-3 运用栈模拟递归 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/03-Non-Recursive-Implementation-of-a-Recursive-Algorithm/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/03-Non-Recursive-Implementation-of-a-Recursive-Algorithm/src/) |
| 6-4 队列的典型应用 Binary Tree Level Order Traversal | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/04-Binary-Tree-Level-Order-Traversal/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/04-Binary-Tree-Level-Order-Traversal/src/) |
| 6-5 BFS和图的最短路径 Perfect Squares | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/05-Perfect-Squares/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/05-Perfect-Squares/src/) |
| 6-6 优先队列 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/06-Priority-Queue/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/06-Priority-Queue/src/) |
| 6-7 优先队列相关的算法问题 Top K Frequent Elements | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/07-Top-K-Frequent-Elements/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/07-Top-K-Frequent-Elements/src/) |
| 补充代码1：二叉树经典前序非递归遍历 | [C++源码](06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/Optional-01-Classic-Non-Recursive-Preorder-Traversal/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/Optional-01-Classic-Non-Recursive-Preorder-Traversal/src/) |
| 补充代码2：二叉树经典中序非递归遍历 | [C++源码](06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/Optional-02-Classic-Non-Recursive-Inorder-Traversal/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/Optional-02-Classic-Non-Recursive-Inorder-Traversal/src/) |
| 补充代码3：二叉树经典后序非递归遍历 | [C++源码](06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/Optional-03-Classic-Non-Recursive-Postorder-Traversal/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/Optional-03-Classic-Non-Recursive-Postorder-Traversal/src/) |
| 补充代码4：二叉树的Morris非递归遍历 | [C++源码](06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/Optional-04-Binary-Tree-Morris-Traversal/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/Optional-04-Binary-Tree-Morris-Traversal/src/) |
| 补充代码5：双向广度优先搜索 Word Ladder | [C++源码](06-Stack-and-Queue/Course%20Code%20(C%2B%2B)/Optional-05-Word-Ladder/) | [Java源码](06-Stack-and-Queue/Course%20Code%20(Java)/Optional-05-Word-Ladder/src/) |
| **第七章：二叉树和递归** | [章节C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/07-Binary-Tree-and-Recursion/Course%20Code%20(C%2B%2B)/) | [章节Java源码](07-Binary-Tree-and-Recursion/Course%20Code%20(Java)/) |
| 7-1 二叉树天然的递归结构 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/07-Binary-Tree-and-Recursion/Course%20Code%20(C%2B%2B)/01-Maximum-Depth-of-Binary-Tree/) | [Java源码](07-Binary-Tree-and-Recursion/Course%20Code%20(Java)/01-Maximum-Depth-of-Binary-Tree/src) |
| 7-2 一个简单的二叉树问题引发的血案 Invert Binary Tree | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/07-Binary-Tree-and-Recursion/Course%20Code%20(C%2B%2B)/02-Invert-Binary-Tree/) | [Java源码](07-Binary-Tree-and-Recursion/Course%20Code%20(Java)/02-Invert-Binary-Tree/src/) |
| 7-3 注意递归的终止条件 Path Sum | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/07-Binary-Tree-and-Recursion/Course%20Code%20(C%2B%2B)/03-Path-Sum/) | [Java源码](07-Binary-Tree-and-Recursion/Course%20Code%20(Java)/03-Path-Sum/src/) |
| 7-4 定义递归问题 Binary Tree Path | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/07-Binary-Tree-and-Recursion/Course%20Code%20(C%2B%2B)/04-Binary-Tree-Paths/) | [Java源码](07-Binary-Tree-and-Recursion/Course%20Code%20(Java)/04-Binary-Tree-Paths/src/) |
| 7-5 稍复杂的递归逻辑 Path Sum III | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/07-Binary-Tree-and-Recursion/Course%20Code%20(C%2B%2B)/05-Path-Sum-III/) | [Java源码](07-Binary-Tree-and-Recursion/Course%20Code%20(Java)/05-Path-Sum-III/src/) |
| 7-6 二分搜索树中问题 Lowest Common Ancestor of a Binary Search Tree | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/07-Binary-Tree-and-Recursion/Course%20Code%20(C%2B%2B)/06-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/) | [Java源码](07-Binary-Tree-and-Recursion/Course%20Code%20(Java)/06-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/) |
| 补充代码1：二分搜索树的完整底层实现 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第六章](https://coding.imooc.com/lesson/207.html#mid=13454) |
| 补充代码2：AVL树的完整底层实现 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第十二章](https://coding.imooc.com/lesson/207.html#mid=14346) |
| 补充代码3：红黑树的完整底层实现 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第十三章](https://coding.imooc.com/lesson/207.html#mid=15086) |
| 补充代码4：使用数组生成二叉树测试用例 | [整理中] | [敬请期待] |
| 补充代码5：普通二叉树的LCA问题 | [整理中] | [敬请期待] |
| 补充代码6：二分搜索树的LCA问题 | [整理中] | [敬请期待] |
| 补充代码7：更多树结构之线段树 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第九章](https://coding.imooc.com/lesson/207.html#mid=13843) |
| 补充代码8：更多树结构之Trie | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第十章](https://coding.imooc.com/lesson/207.html#mid=13850) |
| 补充代码9：更多树结构之并查集 | [玩转数据结构](https://coding.imooc.com/class/207.html) | [第十一章](https://coding.imooc.com/lesson/207.html#mid=14165) |
| **第八章：递归和回溯法** | [章节C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(C%2B%2B)/) | [章节Java源码](08-Recurion-and-Backstracking/Course%20Code%20(Java)/) |
| 8-1 树形问题 Letter Combinations of a Phone Number | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(C%2B%2B)/01-02-Letter-Combinations-of-a-Phone-Number/) | [Java源码](08-Recurion-and-Backstracking/Course%20Code%20(Java)/01-02-Letter-Combinations-of-a-Phone-Number/src/) |
| 8-2 什么是回溯 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(C%2B%2B)/01-02-Letter-Combinations-of-a-Phone-Number/) | [Java源码](08-Recurion-and-Backstracking/Course%20Code%20(Java)/01-02-Letter-Combinations-of-a-Phone-Number/src/) |
| 8-3 排列问题 Permutations | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(C%2B%2B)/03-Permutations/) | [Java源码](08-Recurion-and-Backstracking/Course%20Code%20(Java)/03-Permutations/src/) |
| 8-4 组合问题 Combinations | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(C%2B%2B)/04-Combinations/) | [Java源码](08-Recurion-and-Backstracking/Course%20Code%20(Java)/04-Combinations/src/) |
| 8-5 回溯法解决组合问题的优化 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(C%2B%2B)/05-Combinations-optimized/) | [Java源码](08-Recurion-and-Backstracking/Course%20Code%20(Java)/05-Combinations-optimized/src/) |
| 8-6 二维平面上的回溯法 Word Search | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(C%2B%2B)/06-Word-Search/) | [Java源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(Java)/06-Word-Search/src/) |
| 8-7 floodfill算法，一类经典问题 Number of Islands | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(C%2B%2B)/07-Number-of-Islands/) | [Java源码](08-Recurion-and-Backstracking/Course%20Code%20(Java)/07-Number-of-Islands/src/) |
| 8-8 回溯法是人工智能的基础 N Queens | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/08-Recurion-and-Backstracking/Course%20Code%20(C%2B%2B)/08-N-Queens/) | [Java源码](08-Recurion-and-Backstracking/Course%20Code%20(Java)/08-N-Queens/src/) |
| 补充代码1：更多和生成排列相关 | [整理中] | [敬请期待] |
| 补充代码2：更多和组合相关 | [整理中] | [敬请期待] |
| 补充代码3：更多和八皇后问题相关 | [整理中] | [敬请期待] |
| **第九章：动态规划基础** | [章节C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/) | [章节Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/) |
| 9-1 什么是动态规划 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/01-Fibonacci/) | [Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/01-Fibonacci/src/) |
| 9-2 第一个动态规划问题 Climbing Stairs | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/02-Climbing-Stairs/) | [Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/02-Climbing-Stairs/src/) |
| 9-3 发现重叠子问题 Integer Break | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/03-Integer-Break/) | [Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/03-Integer-Break/src/) |
| 9-4 状态的定义和状态转移 House Robber | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/04-House-Robber/) | [Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/04-House-Robber/src/) |
| 9-5 0-1背包问题 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/05-0-1-knapsack/) | [Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/05-0-1-knapsack/src/) |
| 9-6 0-1背包问题的优化和变种 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/06-0-1-knapsack-optimized/) | [Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/06-0-1-knapsack-optimized/src/) |
| 9-7 面试中的0-1背包问题 Partition Equal Subset Sum | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/07-Partition-Equal-Subset-Sum/) | [Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/07-Partition-Equal-Subset-Sum/src/) |
| 9-8 LIS问题 Longest Increasing Subsequence | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/08-Longest-Increasing-Subsequence/) | [Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/08-Longest-Increasing-Subsequence/src/) |
| 9-9 LCS，最短路，求动态规划的具体解以及更多 | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/09-Longest-Common-Subsequence/) | [Java源码](09-Dynamic-Programming/Course%20Code%20(Java)/09-Longest-Common-Subsequence/src/) |
| 补充代码1：更多和斐波那契数相关 | [C++](09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/Optional-01-More-about-Fibonacci/) | [Java](09-Dynamic-Programming/Course%20Code%20(Java)/Optional-01-More-about-Fibonacci/src/) |
| 补充代码2：LIS问题的O(nlogn)解法 | [C++](09-Dynamic-Programming/Course%20Code%20(C%2B%2B)/Optional-02-More-about-LIS/) | [Java](09-Dynamic-Programming/Course%20Code%20(Java)/Optional-02-More-about-LIS/src/) |
| 补充代码3：更多和背包问题相关 | [整理中] | [敬请期待] |
| 补充代码4：另一个经典DP模型：回文子串数 | [整理中] | [敬请期待] |
| **第十章：贪心算法** | [章节C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/10-Greedy-Algorithms/Course%20Code%20(C%2B%2B)/) | [章节Java源码](10-Greedy-Algorithms/Course%20Code%20(Java)/) |
| 10-1 贪心基础 Assign Cookies | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/10-Greedy-Algorithms/Course%20Code%20(C%2B%2B)/01-Assign-Cookies/) | [Java源码](10-Greedy-Algorithms/Course%20Code%20(Java)/01-Assign-Cookies/src/) |
| 10-2 贪心算法与动态规划的关系 Non-overlapping Intervals | [C++源码](https://github.com/liuyubobobo/Play-with-Algorithm-Interview/tree/master/10-Greedy-Algorithms/Course%20Code%20(C%2B%2B)/02-Non-overlapping-Intervals/) | [Java源码](10-Greedy-Algorithms/Course%20Code%20(Java)/02-Non-overlapping-Intervals/src/) |
| 10-3 贪心选择性质的证明 | [无代码] | [无代码] |
| **第十一章：课程结语** | [无代码] | [无代码] |
| 11-1 结语 | [无代码] | [无代码] |


## 课程练习题及扩展练习题

练习题源码以及更多扩展练习题将在v3版本公布，敬请期待：）

现阶段可以在我的 [**Leetcode题解代码仓**](https://github.com/liuyubobobo/Play-Leetcode) 中查询参考代码。如果在我的题解代码仓中没有你想要的问题的相应的代码，可以随时在课程问答区留言索要相应代码和简单的算法思路说明：）

| 章节 | 讲解例题 | 课程练习题 | 更多扩展练习 | 难题推荐 |
| --- | --- | --- | --- | --- |
| **第一章 算法面试到底是什么鬼?** | [无] | [无] | | |
| **第二章 面试中的复杂度分析** | [无] | [无] | | |
| **第三章 数组中的问题最常见** | | | | |
| 3-1 从二分查找法看如何写出正确的程序 | [无] | [无] | 704 | |
| 3-2 改变变量定义，依然可以写出正确的算法 | [无] | [无] | 34 374 69 33 | |
| 3-3 在LeetCode上解决第一个问题 Move Zeros | 283 | [无] | 728 747 | |
| 3-4 即使简单的问题，也有很多优化的思路 | 283 | 27 26 80 | | |
| 3-5 三路快排partition思路的应用 Sort Color | 75 | 88 215 | | |
| 3-6 对撞指针 Two Sum II - Input Array is Sorted | 167 | 125 344 345 11 | | |
| 3-7 滑动窗口 Minimum Size Subarray Sum | 209 3 | 438 76 | 713 | 159 |
| 补充1：更多数组中的问题 | [无] | [无] | 303 121 122 717 674 268 727 56 485 852 853 868 189 896 739 252 | 123 |
| 补充2：字符数组（字符串） | [无] | [无] | 151 186 557 434 387 696 443 791 800 806 809 67 28 14 859 | |
| 补充3：二维数组中的问题 | [无] | [无] | 36 54 59 598 723 766 794 807 498 118 867 883 885 892 48 | |
| 补充4: 二分查找法的更多问题 | [无] | [无] | 875 153 | 793 |
| **第四章 查找表相关问题** | | | | |
| 4-1 set的使用 Intersection of Two Arrays | 349 | [无] | 874 | |
| 4-2 map的使用 Intersection of Two Arrays II | 350 | [无] | | |
| 4-3 set和map不同底层实现的区别 | 349 350 | 136 242 202 290 205 451 | 705 706 804 | |
| 4-4 使用查找表的经典问题 Two Sum | 1 | 15 18 16 | | |
| 4-5 灵活选择键值 4Sum II | 454 | 49 | 697 734 | |
| 4-6 灵活选择键值 Number of Boomerangs | 447 | 149 719 | | |
| 4-7 查找表和滑动窗口 Contain Duplicate II | 219 | 217 | | |
| 4-8 二分搜索树底层实现的顺序性 Contain Duplicate III | 220 | [无] | 155 716 729 731 855 | |
| 补充1：查找表的更多问题 | [无] | [无] | 170 259 288 290 811 819 869 884 888 890 893 | 128 |
| **第五章 在链表中穿针引线** | | | | |
| 5-1 链表，在节点间穿针引线 Reverse Linked List | 206 | 92 | | |
| 5-2 测试你的链表程序 | 206 | 83 86 328 2 445 | | |
| 5-3 设立链表的虚拟头结点 Remove Linked List Elements | 203 | 82 21 | | |
| 5-4 复杂的穿针引线 Swap Nodes in Pairs | 24 | 25 147 148 | | |
| 5-5 不仅仅是穿针引线 Delete Node in a Linked List | 237 | [无] | | |
| 5-6 链表与双指针 Remove Nth Node Form End of List | 19 | 61 143 234 | | |
| 补充1：更多链表中的问题 | [无] | [无] | 725 817 876 | | 
| 补充2：Floyd环检测算法 | [无] | [无] | 141 142 | 287 |
| **第六章 栈、队列、优先队列** | | | | |
| 6-1 栈的基础应用 Valid Parentheses | 20 | 150 71 | 735 | |
| 6-2 栈和递归的紧密关系 Binary Tree Preorder, Inorder and Postorder Traversal | 144 94 145 | [无] | | |
| 6-3 运用栈模拟递归 | 144 94 145 | 341 | 388 | |
| 6-4 队列的典型应用 Binary Tree Level Order Traversal | 102 | 107 103 199 346 | 232 637 | |
| 6-5 BFS和图的最短路径 Perfect Squares | 279 | 127 126 286 | 752 | 675 |
| 6-6 优先队列 | [无] | [无] | | |
| 6-7 优先队列相关的算法问题 Top K Frequent Elements | 347 | 23 | 692 | 23 239 786 857 |
| 补充1：更多和栈相关的问题 | [无] | [无] | 133 856 227 253 901 | 224 282 772 |
| 补充2：更多和队列相关的问题 | [无] | [无] | 490 622 | |
| **第七章 二叉树和递归** | | | | |
| 7-1 二叉树天然的递归结构 | 104 | 111 | | |
| 7-2 一个简单的二叉树问题引发的血案 Invert Binary Tree | 226 | 100 101 222 110 | | |
| 7-3 注意递归的终止条件 Path Sum | 112 | 111 404 | | |
| 7-4 定义递归问题 Binary Tree Path | 257 | 113 129 222 | 250 | |
| 7-5 稍复杂的递归逻辑 Path Sum III | 437 | [无] | 785 | |
| 7-6 二分搜索树中的问题 Lowest Common Ancestor of a Binary Search Tree | 783 235 | 98 450 108 230 236 530 | | 99 |
| 补充1 更多二叉树的问题 | [无] | [无] | 109 105 106 173 863 865 872 889 894 897 95 | 87 |
| **第八章 递归和回溯法** | | | | |
| 8-1 树形问题 Letter Combinations of a Phone Number | 17 | [无] | 690 | |
| 8-2 什么是回溯 | 17 | 93 131 | 797 | |
| 8-3 排列问题 Permutations | 46 | 47 | 784 | |
| 8-4 组合问题 Combinations | 77 | [无] | | |
| 8-5 回溯法解决组合问题的优化 | 77 | 39 40 216 78 90 401 | 254 | |
| 8-6 二维平面上的回溯法 Word Search | 79 | [无] | | |
| 8-7 floodfill算法，一类经典问题 Number of Islands | 200 | 130 417 | 695 694 733 | 711 |
| 8-8 回溯法是经典人工智能的基础 N Queens | 51 | 52 37 | | |
| 补充1 更多回溯问题 | [无] | [无] | | |
| 补充2 其他递归问题 | [无] | [无] | | 390 |
| **第九章 动态规划基础** | | | | |
| 9-1 什么是动态规划 | [无] | [无] | | |
| 9-2 第一个动态规划问题 Climbing Stairs | 70 | 120 64 | 123 309 714 118 | |
| 9-3 发现重叠子问题 Integer Break | 343 | 279 91 62 63 | | |
| 9-4 状态的定义和状态转移 House Robber | 198 | 213 337 309 | 740 | |
| 9-5 0-1背包问题 | [无] | [无] | | |
| 9-6 0-1背包问题的优化和变种 | [无] | [无] | | 115 |
| 9-7 面试中的0-1背包问题 Partition Equal Subset Sum | 416 | 322 377 474 139 494 | 518 | 805 |
| 9-8 LIS问题 Longest Increasing Subsequence | 300 | 376 | 673 | |
| 9-9 LCS，最短路，求动态规划的具体解以及更多 | [无] | [无] | 583 712 718 | |
| 补充1：状态压缩DP | [无] | [无] | 473 698 | |
| 补充2：更多动态规划问题 | [无] | [无] | 188 790 873 96 | 600 727 741 788 871 879 887 902 903 |
| **第十章 贪心算法** | | | | |
| 10-1 贪心基础 Assign Cookies | 455 | 392 | 561 | |
| 10-2 贪心算法与动态规划的关系 Non-overlapping Intervals | 435 | [无] | | |
| 10-3 贪心选择性质的证明 | [无] | [无] | | |
| 补充1：更多贪心问题 | [无] | [无] | 860 861 870 881 | 765 |

## 课程未涉及内容

| 内容 | 扩展练习 | 难题推荐 |
| --- | --- | --- |
| 字符串 | 722 792 796 | 736 |
| 位运算 | 136 191 389 898 | |
| 数论 | 386 | |
| 线段树 | 307 370 218 | 699 715 308 |
| Trie | 208 720 676 677 648 211 | |
| 并查集 | 737 721 684 | |
| 图论 | 787 886 | 685 765 864 882 |
| 随机算法 | 268 382 398 470 478 497 519 528 | 710 |
| 数学问题 | 119 171 319 360 858 | 878 891 |
| 博弈论 | 877 | |
| 数据结构设计 | 380 900 | 381 895 |
| 其他问题 | 391 780 781 789 795 799 866 880 | 732 899 |

---

注： **课程讲义的PDF版本不在github上提供**，大家可以在慕课网上 "下载 -> 查看讲师源码" 中各个章节文件夹下找到。

**大家加油！：）**